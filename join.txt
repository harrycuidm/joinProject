# -*- coding: utf-8 -*-
"""
JoinQuant｜A股 多因子（分钟运行，09:35 用昨收；其后每小时用盘中价）・ 稳健进取版
- 评估点：09:35（昨收）、10:35/11:35/13:35/14:35（盘中价）
- 无未来函数：基本面=上一交易日快照；小时评估时仅用“截至当前分钟”的最新价补最后一天
- 低换手：缓冲带 + 再平衡阈值；等权 + 行业/单票上限 + 一手约束
- 择时“降仓不空仓”；risk_off 时仍按因子选股（敞口=expo_off），只有没有可下目标时才 ETF 兜底
- 标的池：中证1000（000852.XSHG）
"""

from jqdata import *
import pandas as pd
import numpy as np
from collections import defaultdict
from datetime import time as _t, datetime as _dt, timedelta as _td

# ========================= 参数 =========================
def set_params(context):
    # 基准&标的池（仅中证1000）
    g.benchmark = '000852.XSHG'
    g.base_indices = ['000852.XSHG']

    # ―― 静态过滤（放宽以扩大池子） ―― #
    g.min_days_listed = 60
    g.min_turnover_60d = 2e7      # 近60日均成交额≥2000万
    g.min_mktcap = 3e9            # 总市值≥30亿（元）

    # 因子窗口（日频）
    g.lb_mom = 126
    g.skip_recent = 21
    g.lb_mom3 = 63
    g.vol_win = 60

    # 因子权重
    g.w = dict(value=0.25, quality=0.25, momentum=0.30, lowvol=0.20)

    # 目标持仓数量 & 换手控制
    g.topN = 30                   # 分散一点更稳
    g.exit_buffer = 1.5
    g.reweight_eps = 0.02         # 阈值更灵敏

    # 权重约束
    g.max_weight = 0.08
    g.max_ind_weight = 0.35
    g.min_pos_value = 4000

    # 择时与敞口（降仓不空仓）
    g.ma_long = 200
    g.ma_short = 20
    g.vol_gate = None             # None=不开波动率闸门；或设 0.20
    g.expo_on  = 1.00
    g.expo_off = 0.80

    # 风控（组合层）& 逐股止盈止损（默认关闭）
    g.max_drawdown_step = 0.20    # 组合回撤大于20%转 risk_off
    g.enable_trailing_stop = False
    g.trail_stop = 0.15
    g.enable_take_profit = False
    g.take_profit = 0.30

    # 交易执行
    g.order_batches = 2
    g.fallback_etf_on = True
    g.fallback_etf_candidates = [
        '512100.XSHG',   # 中证1000ETF（沪）
        '159845.XSHE',   # 中证1000ETF（深）
        '510500.XSHG',   # 中证500ETF（沪）
        '510300.XSHG',   # 沪深300ETF（沪）
        '159919.XSHE',   # 沪深300ETF（深）
    ]
    g.fallback_etf = g.fallback_etf_candidates[0]

    # 运行态
    g.risk_on = True
    g._last_risk_on_flag = g.risk_on
    g.highest_equity = context.portfolio.total_value
    g.stock_high = defaultdict(float)   # 个股历史高点（止损用）
    g.stock_base = defaultdict(float)   # 个股建仓价（止盈用）
    g.last_target = pd.Series(dtype=float)  # 上次目标权重

    # 当日评估时刻（固定 5 个点）
    g.eval_time_points = [_t(9,35), _t(10,35), _t(11,35), _t(13,35), _t(14,35)]
    g.eval_done_times = set()

# ========================= 环境判定 =========================
def _is_minute_env(context):
    try:
        return str(context.run_params.get('frequency', '')).lower() == 'minute'
    except Exception:
        return True

# ========================= 初始化与钩子 =========================
def initialize(context):
    set_params(context)
    set_benchmark(g.benchmark)
    set_option('use_real_price', True)
    log.set_level('order', 'info')

    set_order_cost(OrderCost(open_tax=0, close_tax=0.001,
                             open_commission=0.00015, close_commission=0.00015,
                             close_today_commission=0, min_commission=5), type='stock')
    set_slippage(PriceRelatedSlippage(0.0015))

    # 日频环境：09:35 触发一次评估
    if not _is_minute_env(context):
        run_daily(task_daily_eval, time='09:35')

def before_trading_start(context):
    g.eval_done_times = set()
    g.highest_equity = max(g.highest_equity, context.portfolio.total_value)

def after_trading_end(context):
    g.highest_equity = max(g.highest_equity, context.portfolio.total_value)
    dd = context.portfolio.total_value / g.highest_equity - 1.0
    record(risk_on=int(g.risk_on), dd=float(dd), cash=float(context.portfolio.cash))

# ========== 分钟驱动 ==========
def handle_data(context, data):
    task_minutely(context)

# ========== 日频环境评估 ==========
def task_daily_eval(context):
    portfolio_guard(context)
    market_timing(context)
    rebalance(context, use_intraday=False)

# ========================= 工具 =========================
def prev_trade_ts(dt_like):
    cal = pd.DatetimeIndex(get_all_trade_days())
    ts  = pd.Timestamp(dt_like)
    i   = cal.searchsorted(ts, side='left') - 1
    i   = int(max(i,0))
    return cal[i]

def winsorize(s, n=3.0):
    s = s.astype(float)
    if s.std()==0 or s.isnull().all(): return s
    m, sd = s.mean(), s.std()
    return s.clip(m-n*sd, m+n*sd)

def zscore(s):
    s = s.astype(float)
    sd = s.std()
    if sd==0 or s.isnull().all(): return s*0
    return (s-s.mean())/sd

def _cd_get(code):
    cd = get_current_data()
    try: return cd[code]
    except:
        try: return cd.get(code, None)
        except: return None

def industry_series(stocks):
    ind = get_industry(stocks)
    res = {}
    for s in stocks:
        try:
            sw1 = ind.get(s,{}).get('sw_l1',None)
            res[s] = None if sw1 is None else sw1.get('industry_code',None)
        except:
            res[s] = None
    return pd.Series(res)

def neutralize_ind_cap(factor, industry, mcap):
    df = pd.DataFrame({'f':factor,'ind':industry}).dropna()
    if df.empty: return factor*0
    df['intra'] = df.groupby('ind')['f'].transform(lambda x: zscore(x.fillna(x.mean())))
    cap = np.log(pd.Series(mcap).reindex(df.index).replace(0,np.nan))
    X = pd.DataFrame({'const':1.0,'logcap':cap}).fillna(0.0)
    y = df['intra'].fillna(0.0)
    try:
        beta = np.linalg.lstsq(X.values, y.values, rcond=None)[0]
        resid = y - X.values.dot(beta)
    except:
        resid = y
    out = zscore(pd.Series(resid, index=df.index))
    return out.reindex(factor.index)

# ============= 价格：获取“截至当前分钟”的最新收盘，安全拼接到日线 =============
def latest_minute_close(context, stocks):
    end_dt = context.current_dt - _td(minutes=1)
    if end_dt.time() < _t(9,31):
        return pd.Series(index=stocks, dtype=float)
    try:
        pxm = get_price(stocks, end_date=end_dt, count=1, frequency='1m',
                        fields=['close'], panel=False)
        if pxm is None or pxm.empty:
            return pd.Series(index=stocks, dtype=float)
        last = pxm.pivot(index='time', columns='code', values='close').iloc[-1]
        return last.reindex(stocks)
    except:
        return pd.Series(index=stocks, dtype=float)

def patch_with_intraday(close_daily_df, last_intraday_series):
    if last_intraday_series is None or last_intraday_series.empty:
        return close_daily_df
    patched = close_daily_df.copy()
    cols = [c for c in patched.columns if c in last_intraday_series.index]
    if len(cols) == 0: return patched
    patched.iloc[-1, patched.columns.get_indexer(cols)] = last_intraday_series.reindex(cols).values
    return patched

# ========================= 标的池（CSI1000 + 流动性） =========================
def build_universe(context):
    today = context.current_dt.date()
    base = set()
    for idx in g.base_indices:
        try: base |= set(get_index_stocks(idx, today))
        except: pass
    pool = list(base)
    log.info(f"[POOL0] base(CSI1000)={len(pool)}")

    # 上市天数
    def enough_days(s):
        try: return (today - get_security_info(s).start_date).days >= g.min_days_listed
        except: return False
    pool = [s for s in pool if enough_days(s)]

    # 近60日成交额（上一交易日）
    d_end = prev_trade_ts(today)
    if not pool:
        return []
    px = get_price(pool, count=max(g.vol_win,60), end_date=d_end, fields=['money'], panel=False)
    if px is None or px.empty:
        log.info("[POOL] no price for liquidity check"); return []
    money = px.pivot(index='time', columns='code', values='money').mean()
    pool = [s for s in pool if (s in money and money[s] >= g.min_turnover_60d)]

    # 市值（上一交易日）
    if not pool:
        return []
    q = query(valuation.code, valuation.market_cap).filter(valuation.code.in_(pool))
    mc = get_fundamentals(q, date=d_end)
    ok = set(mc[mc['market_cap']*1e8 >= g.min_mktcap]['code'])
    pool = [s for s in pool if s in ok]

    log.info(f"[POOL] after static/liquidity filters={len(pool)}")
    return pool

# ========================= 多因子：日频+可选盘中补价 =========================
def compute_factors(context, stocks, use_intraday=False):
    dt = prev_trade_ts(context.current_dt.date())
    q = query(valuation.code, valuation.pe_ratio, valuation.pb_ratio, valuation.ps_ratio,
              valuation.market_cap,
              indicator.roe, indicator.gross_profit_margin,
              indicator.inc_net_profit_year_on_year, indicator.inc_revenue_year_on_year
             ).filter(valuation.code.in_(stocks))
    gf = get_fundamentals(q, date=dt).set_index('code')

    cnt = max(g.lb_mom+g.skip_recent+1, g.vol_win+1, g.lb_mom3+1)
    px = get_price(stocks, count=cnt, end_date=dt, fields=['close'], panel=False)
    if px is None or px.empty:
        log.info("[FACT] no price"); return None
    close = px.pivot(index='time', columns='code', values='close').sort_index()

    if use_intraday:
        last_intraday = latest_minute_close(context, stocks)
        if not last_intraday.empty:
            close = patch_with_intraday(close, last_intraday)

    ret = close.pct_change()
    mom_12_1 = (close.iloc[-(g.skip_recent+1)] / close.iloc[-(g.lb_mom+g.skip_recent+1)]) - 1.0
    mom_3m   =  close.iloc[-1] / close.iloc[-(g.lb_mom3+1)] - 1.0
    vol = ret.iloc[-g.vol_win:].std()

    industry = industry_series(stocks)
    mcap = (gf['market_cap']*1e8).reindex(stocks)

    value_raw    = (zscore(winsorize(-gf['pe_ratio'].reindex(stocks))) +
                    zscore(winsorize(-gf['pb_ratio'].reindex(stocks))) +
                    zscore(winsorize(-gf['ps_ratio'].reindex(stocks))))
    quality_raw  = (zscore(winsorize(gf['roe'].reindex(stocks))) +
                    zscore(winsorize(gf['gross_profit_margin'].reindex(stocks))) +
                    zscore(winsorize(gf['inc_net_profit_year_on_year'].reindex(stocks))) +
                    zscore(winsorize(gf['inc_revenue_year_on_year'].reindex(stocks))))
    momentum_raw = zscore(winsorize(mom_12_1.reindex(stocks))) + 0.5*zscore(winsorize(mom_3m.reindex(stocks)))
    lowvol_raw   = zscore(winsorize((-vol).reindex(stocks)))

    value    = neutralize_ind_cap(value_raw, industry, mcap)
    quality  = neutralize_ind_cap(quality_raw, industry, mcap)
    momentum = neutralize_ind_cap(momentum_raw, industry, mcap)
    lowvol   = neutralize_ind_cap(lowvol_raw, industry, mcap)

    fac = pd.DataFrame({
        'value':value, 'quality':quality, 'momentum':momentum, 'lowvol':lowvol,
        'vol':vol.reindex(stocks), 'industry':industry.reindex(stocks), 'mcap':mcap
    }).dropna(subset=['value','quality','momentum','lowvol','vol'])

    log.info(f"[FACT] computed(use_intraday={use_intraday}) for {len(fac)} stocks")
    return fac

def score_rank(factors):
    w = g.w
    s = (w['value']*factors['value'] + w['quality']*factors['quality'] +
         w['momentum']*factors['momentum'] + w['lowvol']*factors['lowvol'])
    ranked = factors.assign(score=s).sort_values('score', ascending=False)
    ranked['rk'] = np.arange(1, len(ranked)+1)
    log.info(f"[SCORE] top5={ranked.head(5).index.tolist()}")
    return ranked

# ========================= 择时（更宽松，降仓不空仓） =========================
def market_timing(context):
    idx = g.benchmark
    dt  = prev_trade_ts(context.current_dt.date())
    cnt = max(g.ma_long, g.ma_short) + 1
    p   = get_price(idx, count=cnt, end_date=dt, fields=['close'], panel=False)
    if p is None or p.empty:
        g.risk_on = True; return g.risk_on
    close = p['close'].values
    maL, maS = close[-g.ma_long:].mean(), close[-g.ma_short:].mean()

    if g.vol_gate:
        vol20 = pd.Series(close).pct_change().dropna().iloc[-20:].std()
        vol_ok = (vol20 < g.vol_gate)
    else:
        vol_ok = True

    # 条件：短均上长均 或 价格上长均，且波动率合格
    g.risk_on = ((maS > maL) or (close[-1] > maL)) and vol_ok
    log.info(f"[TIMING] price={close[-1]:.2f} maS={maS:.2f} maL={maL:.2f} vol_ok={vol_ok} -> risk_on={g.risk_on}")
    return g.risk_on

# ========================= 组合构建（缓冲带 + 等权） =========================
def est_lot_value(context, code):
    d = _cd_get(code)
    p = None
    if d:
        p = d.last_price if (d.last_price and d.last_price>0) else (d.day_open if (d.day_open and d.day_open>0) else None)
    if p is None:
        ref = prev_trade_ts(context.current_dt.date())
        try:
            p = float(get_price(code, count=1, end_date=ref, fields=['close'], panel=False)['close'].iloc[-1])
        except:
            p = 10.0
    return float(max(p,1.0) * 100.0)

def cap_industry(weights, industry, cap=0.35, iters=3):
    w = weights.copy()
    for _ in range(iters):
        by = w.groupby(industry.reindex(w.index)).sum()
        over = by[by>cap]
        if over.empty: break
        for ind in over.index:
            idx = w.index[industry.reindex(w.index)==ind]
            w.loc[idx] = w.loc[idx] * (cap/by[ind])
        w = w/w.sum()
    return w

def build_target(context, ranked):
    total = context.portfolio.total_value
    expo  = g.expo_on if g.risk_on else g.expo_off
    budget = total * expo

    rk = ranked['rk']
    held = [s for s in context.portfolio.positions.keys() if s in rk.index and s != g.fallback_etf]

    # ―― 动态缩小目标持仓数：保证等权后每只 ≥ min_pos_value ―― #
    max_by_budget = max(1, int(budget // max(g.min_pos_value, 1)))
    N_target = min(g.topN, max_by_budget)

    # 缓冲带：保留在退出阈值内的旧仓，但不超过 N_target
    keep = [s for s in held if rk.loc[s] <= g.topN * g.exit_buffer]
    keep = sorted(keep, key=lambda s: rk.loc[s])[:N_target]

    # 用前 N_target 补齐
    add = []
    for s in ranked.head(N_target*2).index:
        if s not in keep and len(keep)+len(add) < N_target:
            add.append(s)
    target_codes = keep + add
    if not target_codes:
        return pd.Series(dtype=float)

    # 等权初始权重 + 单票上限
    w = pd.Series(1.0/len(target_codes), index=target_codes)
    w = w.clip(upper=g.max_weight)
    w = w / w.sum()

    # 行业约束
    inds = ranked['industry'].reindex(w.index)
    w = cap_industry(w, inds, cap=g.max_ind_weight)

    # 一手金额/最小金额约束：若不达标则缩 N 再试
    while True:
        invest = w * budget
        bad = []
        for s in w.index:
            need = max(est_lot_value(context, s), g.min_pos_value)
            if invest.loc[s] + 1e-6 < need:
                bad.append(s)
        if not bad:
            break
        w = w.drop(bad)
        if w.empty:
            break
        w = w / w.sum()

    return (w * expo)

# ========================= 执行层（阈值调仓 + ETF 兜底） =========================
def tradable_for_order(code, verbose=False):
    d = _cd_get(code)
    if d is None:
        if verbose: log.info(f"[CHK] {code} no current_data -> deny"); 
        return False
    if d.is_st:
        if verbose: log.info(f"[CHK] {code} is_st=True -> deny"); 
        return False
    p  = d.last_price or d.day_open
    hl = getattr(d,'high_limit',None); ll = getattr(d,'low_limit',None)
    if p and hl and ll:
        if p >= 0.999*hl:
            if verbose: log.info(f"[CHK] {code} p≈high_limit -> deny"); 
            return False
        if p <= 1.001*ll:
            if verbose: log.info(f"[CHK] {code} p≈low_limit -> deny"); 
            return False
    if verbose: log.info(f"[CHK] {code} tradable=True")
    return True

def pick_fallback_etf(context):
    today = context.current_dt.date()
    d_end = prev_trade_ts(today)
    for etf in g.fallback_etf_candidates:
        try:
            info = get_security_info(etf)
            if info.start_date > today:
                continue
            px = get_price(etf, count=1, end_date=d_end, fields=['close'], panel=False)
            if px is None or px.empty:
                continue
            last = float(px['close'].iloc[-1])
            if np.isnan(last) or last <= 0:
                continue
            return etf
        except Exception:
            continue
    return None

# ―― submit_orders：有个股目标则按目标下；无目标时且 risk_off 才 ETF 兜底 ―― #
def submit_orders(context, target_w):
    total = context.portfolio.total_value

    # 若没有股票目标，并且处于 risk_off，尝试 ETF 兜底；否则保持现金
    if (target_w is None or target_w.empty) and (not g.risk_on) and g.fallback_etf_on:
        etf = pick_fallback_etf(context)
        # 清掉所有非 ETF 持仓
        for s in [x for x in context.portfolio.positions.keys() if x != etf]:
            if tradable_for_order(s, verbose=True):
                log.info(f"[SELL] {s} -> 0 (risk_off fallback)")
                order_target_value(s, 0)
                g.stock_high.pop(s, None); g.stock_base.pop(s, None)
        if etf is not None:
            if g.fallback_etf != etf:
                log.info(f"[FALLBACK_PICK] use {etf} instead of {g.fallback_etf}")
                g.fallback_etf = etf
            tgt = total * g.expo_off
            log.info(f"[FALLBACK] risk_off -> {etf} value={tgt:.0f}")
            try:
                order_target_value(etf, tgt)
            except Exception as e:
                log.info(f"[FALLBACK_FAIL] {e}")
        else:
            log.info("[FALLBACK_SKIP] no usable ETF today -> keep cash")
        return

    # 有股票目标（无论 risk_on / risk_off），都按 target_w 执行；先清 ETF
    if g.fallback_etf in context.portfolio.positions:
        try:
            log.info(f"[FALLBACK_CLEAR] have stock targets -> sell {g.fallback_etf}")
            order_target_value(g.fallback_etf, 0)
        except:
            pass

    # 当前持仓与目标集合
    cur_pos = set([s for s in context.portfolio.positions.keys() if s != g.fallback_etf])
    tgt_pos = set(target_w.index) if target_w is not None else set()

    # 清掉不在目标内的
    for s in cur_pos - tgt_pos:
        if tradable_for_order(s, verbose=True):
            log.info(f"[SELL] {s} -> 0")
            order_target_value(s, 0)
            g.stock_high.pop(s, None); g.stock_base.pop(s, None)

    if target_w is None or target_w.empty:
        return  # 没有股票目标且未走 ETF 兜底：保持现金

    # ======= 阈值只对“已有持仓”生效，不抑制新开仓 =======
    tw = target_w.copy()
    for s in list(tw.index):
        cur = context.portfolio.positions[s].value / total if s in context.portfolio.positions else 0.0
        if (s in context.portfolio.positions) and (abs(tw.loc[s] - cur) < g.reweight_eps):
            tw.loc[s] = cur
    if tw.sum() > 0:
        tw = tw / tw.sum() * target_w.sum()
    else:
        return

    # 分批按金额下单
    parts = np.array_split(tw.index.tolist(), g.order_batches)
    for part in parts:
        for s in part:
            if not tradable_for_order(s, verbose=True):
                log.info(f"[SKIP] {s} not tradable at order time")
                continue
            target_value = float(tw.loc[s] * total)
            if target_value <= 0:
                continue
            log.info(f"[BUY/ADJ] {s} -> target_val={target_value:.0f}")
            order_target_value(s, target_value)

            d = _cd_get(s)
            p = (d.last_price or d.day_open) if d else None
            if p and p > 0:
                if s not in g.stock_base: g.stock_base[s] = p
                g.stock_high[s] = max(g.stock_high.get(s, p), p)

# ========================= 风控（组合降仓 & 个股止损/止盈-可选） =========================
def portfolio_guard(context):
    total = context.portfolio.total_value
    g.highest_equity = max(g.highest_equity, total)
    dd = total/g.highest_equity - 1.0
    if dd <= -g.max_drawdown_step:
        if g.risk_on: log.info(f"[DD_RISK_OFF] drawdown={dd:.2%}")
        g.risk_on = False

    # 个股止盈/止损默认关闭；若要启用，打开两个开关
    if not (g.enable_trailing_stop or g.enable_take_profit):
        return

    for s, pos in list(context.portfolio.positions.items()):
        if s == g.fallback_etf: continue
        d = _cd_get(s)
        p = (d.last_price or d.day_open) if d else None
        if p is None or p <= 0: continue
        g.stock_high[s] = max(g.stock_high.get(s, p), p)

        if g.enable_trailing_stop and p <= g.stock_high[s]*(1.0 - g.trail_stop) and tradable_for_order(s, verbose=True):
            log.info(f"[STOP] {s} trailing stop")
            order_target_value(s, 0)
            g.stock_high.pop(s, None); g.stock_base.pop(s, None)
            continue
        base = g.stock_base.get(s, p)
        if g.enable_take_profit and base > 0 and p >= base*(1.0 + g.take_profit) and tradable_for_order(s, verbose=True):
            log.info(f"[TAKE_PROFIT] {s} +{g.take_profit:.0%}")
            order_target_value(s, 0)
            g.stock_high.pop(s, None); g.stock_base.pop(s, None)

# ========================= 再平衡（评估触发时调用） =========================
def rebalance(context, use_intraday=False):
    portfolio_guard(context)

    pool = build_universe(context)
    if len(pool) == 0:
        log.info("[REBAL] pool empty")
        submit_orders(context, pd.Series(dtype=float))
        g.last_target = pd.Series(dtype=float)
        return

    fac = compute_factors(context, pool, use_intraday=use_intraday)
    if fac is None or fac.empty:
        log.info("[REBAL] factors empty")
        submit_orders(context, pd.Series(dtype=float))
        g.last_target = pd.Series(dtype=float)
        return

    ranked = score_rank(fac)
    target_w = build_target(context, ranked)

    log.info(f"[REBAL] use_intraday={use_intraday} codes={len(target_w)} expo={target_w.sum():.2%} keep={(set(context.portfolio.positions.keys()) & set(target_w.index))}")
    submit_orders(context, target_w)
    g.last_target = target_w

# ========================= 分钟任务（含“09:35 + 每小时一次”评估） =========================
def _is_trading_minute(context):
    t = context.current_dt.time()
    if _t(9,30) <= t <= _t(11,30): return True
    if _t(13,0) <= t <= _t(14,57): return True
    return False

def _should_evaluate_now(context):
    if not _is_trading_minute(context):
        return None
    tnow = context.current_dt.time().replace(second=0, microsecond=0)
    for tp in g.eval_time_points:
        if tnow >= tp and tp not in g.eval_done_times:
            return tp
    return None

def task_minutely(context):
    portfolio_guard(context)

    if g._last_risk_on_flag != g.risk_on:
        log.info(f"[RISK_SWITCH] {g._last_risk_on_flag} -> {g.risk_on}, sync positions with last_target/ETF")
        submit_orders(context, g.last_target if isinstance(g.last_target, pd.Series) else pd.Series(dtype=float))
        g._last_risk_on_flag = g.risk_on

    tp = _should_evaluate_now(context)
    if tp is not None:
        market_timing(context)
        use_intraday = (tp != _t(9,35))
        log.info(f"[EVAL] trigger at {tp.strftime('%H:%M')} use_intraday={use_intraday} risk_on={g.risk_on}")
        rebalance(context, use_intraday=use_intraday)
        g.eval_done_times.add(tp)

    if context.current_dt.time() >= _t(14,56):
        g.highest_equity = max(g.highest_equity, context.portfolio.total_value)
        dd = context.portfolio.total_value / g.highest_equity - 1.0
        record(risk_on=int(g.risk_on), dd=float(dd), cash=float(context.portfolio.cash))
